
\section{程序实现}
\subsection{系统整体架构}

本次实验的主要探究对象是多段线性回归问题。我将多段线性回归拆分成了三个子问题，且三个子问题是迭代求解的。因此在系统层面，我也迭代地对系统进行构建，使得功能逐层封装，有利于实验整体思想脉络的把握以及方便阅读者更快理解我的代码。我的设计是，首先实现一个 SimplePLR 类，用于对已知断点位置的多段线性回归问题进行建模和求解。接下来，在类 SimplePLR 的基础上，构建 PLR 类继承 SimplePLR 类，并实现已知断点数目的多段线性回归问题，包括求解全局最优的断点位置等。在求解全局最优的断点位置的时候需要使用差分进化算法，因此再实现一个 DifferentialEvolution 类，实现需要的差分进化算法的静态函数，包括不同版本：正式版和调试版。最后，在主程序中实现了以上三个类的多个测试函数以及最终的实际应用程序。类实现的UML图如 \ref{image1} 所示。

\begin{figure}[H]
    \center{\includegraphics*[width = .8\textwidth]{./figure/chapter5/uml.png}}
    \caption{系统UML}
    \label{image1}      
\end{figure}

\subsection{SimplePLR 类实现}

这个类中，首先需要输入数据作为模型的训练数据；在该子问题中，问题进一步细化为：生成回归矩阵，求解普通线性回归问题，计算各分段函数斜率截距，计算标准差，计算判定系数，对接下来的数据进行预测。这些子问题分别由函数$regression\_matrix(breaka,x)$，$simple\_plr\_v1(breaks) \rightarrow linear\_regression(A)$，$calculate\_slopes()$，$standard\_errors()$，$r\_squared()$，$predict(x)$实现。

在进行建模过程中，需要先调用$SimplePLR$创建模型对象，并向其中传入自变量和应变量数据。注意，这里的数据可以为list对象也可以为np.ndarray对象。随后，程序会初始化建立训练集，并初始化相关变量。在创建好模型后，就可以直接调用$simple\_plr\_v1(breaks)$函数将数据集划分为多端的线性函数。需要注意的是，在解决已知断点位置的多段线行规划问题中，需要事先人工找出断点位置。读者如果感兴趣，可以继续读下去，稍后我会告诉你如何传入断点位置。随后，就可以进行多项操作，比如进行数据的预测$predict(x)$，其中$x$为新的数据。需要注意的是，这里的测试数据的值域需要包含于训练集的值域。这样规定是合理，因为多段线性回归问题的本身决定了我们只能预测已知域中的数据，而对于已知域外的数据，模型只会利用第一段或者最后一段的线性函数进行预测，而这样显然会出现问题，因为我们没有从已知数据集推断后续数据集的能力，这样的问题交给其它课题。

同时，使用者还可以调用$standard\_errors()$，$r\_squared()$函数来计算标准差和判定系数对训练结果进行一个初步的评估。同时，使用者也可以直接查看模型中的$ss_res$值，来得到残差平方和。需要注意的是，在后续的全局优化中，我正是使用残差平方和来评价一种断点位置的优劣的。

SimplePLR类中各种函数调用依赖关系如下 \ref{image2} 图所示：

\begin{figure}[H]
    \center{\includegraphics*[width = .8\textwidth]{./figure/chapter5/SimplePLR_method.png}}
    \caption{系统UML}
    \label{image2}      
\end{figure}

其中，$regression\_matrix(breaka,x)$的计算方法完全依照 \nameref{p1} 节给出的计算方法。$plot()$用于数据可视化，输出展示的图像上，有源数据和拟合多段线性函数，供使用者从整体上评估模型的优劣。

需要注意的是，由于数据集不一定规范，所以根据 \nameref{p1} 节计算标准差时，可能出现回归矩阵奇异的情况，此时$standard\_errors()$会抛出奇异矩阵的异常，此时使用者可以考虑修正数据集或者不再考虑标准差。因为本次实验时间紧迫，所以没有采用更复杂的处理方法。在实际完整的项目中，可以实现对数据进行预处理，使得数据集中不存在自变量完全相同的两个数据，从而避免回归矩阵奇异的情况。

\subsection{PLR 类实现}

PLR类是在继承类 SimplePLR 类的基础上实现的。综合来讲，PLR类完成的工作就是找到全局最优的断点位置，而断点中，已经有两个断点位置确定，第一个断点和最后一个断点。也就是说，我们需要确定的位置数为$breakpoints - 2$。为此，重新实现一个函数$simple\_plr(mid_breaks)$，每次只传入中间$breakspoints - 2$个参数，用该函数的返回结果$ss\_res$作为评估的指标，即需要优化断点位置以使得残差平方和最小。当然，如果读者还想引入其他的指标来优化断点位置，可以仿照$simple\_plr(mid_breaks)$实现评估函数。

同时，为了方便调试得到中间结果和观察迭代过程中的变化，我还实现了一种调试版本的$fit\_debug(n\_segments)$函数，其与普通的$fit(n\_segments)$函数的唯一区别就是，其调用的是调试版本的差分进化算法，具体实现在 \nameref{de} 节中介绍。当需要中间调试信息的时候，使用者可以调用调试版本的$fit\_debug(n\_segments)$函数即可，函数中已经将每次迭代后结果呈现在plt中，最终打印输出图像就可以观察到待优化函数随着迭代次数的增加而变化的曲线。

在$fit$函数中，首先根据给定的分段数和收尾断点位置来生成$bounds$作为中间断点位置的域；然后调用$differential\_evolution(simple\_plr, bounds)$函数来得到全局最优断点位置（其中$simple\_plr$是传入的待优化函数变量）；得到断点位置后就可以调用从 SimplePLR 继承的$simple\_plr\_v1$函数来解决已知断点位置的多段线性回归问题。

\subsection{DifferentialEvolution 类实现 \label{de}}

DifferentialEvolution 类封装了差分进化算法。在本次实验中，为了简便起见，差分进化算法采用$rand/1/bin$突变策略。

接下来简要介绍差分进化算法的策略组成。其中$rand$字段可选$rand,best,rand-to-best$策略等，分别表示随机选取个体，选取最佳个体和随机选择个体以及最佳个体；$1$字段可选$1$和$2$，分别表示取一对两个体之差和两对两个体只差来生成突变个体，即差向量的数量；$bin$字段可选$bin$和$exp$，分别表示二项式模式和指数模式，二项式模式表示每个变量都具有相同的概率进行重组，指数模式表示随机选取序列中连续的长度为$n$的子序列进行重组。差分进化算法的策略可以通过排列组合上述字段形成多种策略，每种策略在各种不同的实际应用中都有不同的特性，使用者应该根据实际需求选取合适的进化策略。部分进化策略如表 \ref{tab1} 所示。

\begin{table}
    \renewcommand{\arraystretch}{1.3}
        \caption{差分进化算法策略选择}
    \label{tab1}
    \centering
    \begin{tabular}{cc}
        \toprule
    重组策略& 方案\\
        \midrule
    Rand/1 & $x_{mut} = x_{r1} + F(x_{r2} - x_{r3})$  \\

    Rand/2 & $x_{mut} = x_{r1} + F(x_{r2} - x_{r3} + x_{r4} - x_{r5})$\\

    Best/1 & $x_{best} = x_{r1} + F(x_{r2} - x_{r3})$\\

    Best/2 & $x_{best} = x_{r1} + F(x_{r2} - x_{r3} + x_{r4} - x_{r5})$\\

    Rand-to-Best/1 & $x_{mut} = x_{r1} + F_1(x_{r2} - x_{r3}) + F_2(x_{best} - x_{r1})$\\
        \bottomrule
    \end{tabular}
\end{table}

具体实现在此就不再赘述，读者可以参考 \nameref{p2} 中对差分进化算法的介绍，或者直接阅读源文件中的DiferentialEvolution类的源码，我已经写了较为详细的注释方便理解。

\subsection{主程序实现}

主程序$(main.py)$主要包含一些对代码模块功能测试的函数以及最后的一个小应用。接下来逐个介绍个函数的作用。

\begin{enumerate}[(1)]
    \item simple\_plr\_tester1()
    
    使用SimplePLR类构建模型，进行已知断点位置的多段线性回归。函数中已经给出了样例数据以及样例断点。需要注意的，断点还需要传入首位两个断点，即数据集中自变量的最小值和最大值。

    多次改变断点的数目和位置，就可以得到不同的拟合曲线，对比各种不同曲线，即相应的标准差和残差平方和等，我们可以大致判断出那种断点位置是最佳的，不过也可以从中感受到手动设置断点位置的麻烦之处。
    \item plr\_tester1()
    
    使用 PLR 类构建模型，进行已知断点数目位置的多段线性回归。因为需要确定全局最优的断点位置，所以在构建模型之后还需要调用$fit$函数进行优化。

    在这一步中，可以多次改变分段的数目来观察不同分段数目下模型的拟合效果，这可以通过观察可视化曲线以及相关指标来评价。
    \item plr\_tester2()
    
    此测试函数是在$plr\_tester1()$的基础上构建的，通过遍历多个分段数，每个分段数都输出拟合曲线的图像，最终输出判定系数随着分段数的增加而变化的曲线。通过观察这些曲线，我们能够得到一些粗略的结论，并能够理解模型运行背后的动态变化规律。
    \item de\_tester1()
    
    这个测试程序是单独用来测试差分进化算法的收敛速度的。首先给出我们的实例函数$lambda x: sum(x ** 2) / d$，其中$d$表示数据的维数，取值为$8,16,32,64$，$x$为维数为$d$的自变量，变化范围为$(-100,100)$。

    遍历四种维数，分别调用调式版本差分进化算法，得到每种维数下，随着迭代次数的增加实例函数的值的变化规律，从而观察差分进化算法收敛速度和维数之间的关系。
    \item de\_tester2()
    
    该测试函数是在de\_tester1()的基础上进行的。对于给定的实例数据集，通过 PLR 类建立模型。给定一系列分段数，遍历这些分段数，并在每次遍历时，调用调试版本的$fit()$函数，这样就得到了每个分段数对应的差分进化算法收敛情况与迭代次数的关系。将这些曲线绘制到同一张图中就可以直观的观察到不同分段数对收敛速度的影响，并判断出那种分段数相对来说最优。
    \item de\_tester3()
    
    此测试函数是为了观察分段线性回归模型对于非多项式函数的拟合情况。生成一个余弦函数的数据集，并在每个数据的因变量上加上随机的偏置量，来模拟自然情况下的分布。随后，设置不同的分段数，在该数据集上运行分段线性回归，将回归曲线绘制在同一张图上，观察不同曲线拟合的异同点。从这个测试中也可以看到，分段线性回归模型对于大致分析数据集分布和趋势的优势。该模型非常简单，并能直观反映出数据集的大致分布。
    \item application()
    
    接下来是使用分段线性模型来进行一个简单的小应用。此函数是用于获取数据集的函数。这个小应用是对过去一段时间中上证指数每日走势的一个分段线性回归。做这个应用的目的不是为了预测未来走势，而是从走势图中更进一步抽象出在这段时间内上证指数的变化拐点（前面也提到过，用分段线性函数预测域外值是十分不明智的做法）。为此，我选取$baostock$库作为我获取大盘走势数据的API。此函数获取数据的流程也十分简单，首先需登录，然后请求数据，将获取的每列数据整合进pd.DataFrame中，最后将数据存储在项目文件夹下的
    
    /data/history\_A\_stock\_k\_data.csv。
    \item app\_plr()
    
    这个函数用来从获取的数据取出我们所需要的部分，并根据该数据通过类 PLR 建立模型，进行数据的训练，并最终得到训练结果。设置不同的分段数目，得到了不同的分段函数，将这些函数绘制在一张图像中，这样我们就可以大致观察出不同分段数对模型的拟合情况的好坏。

    需要注意的是，根据前文 \nameref{p3} 的论述，在本次实验中仅通过在一定范围内遍历分段数目来确定效果较为优良的分段数，而没有实现动态规划思想。
\end{enumerate}


